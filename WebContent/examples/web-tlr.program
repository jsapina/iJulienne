***(

    This file is part of the Maude 2 interpreter.

    Copyright 1997-2006 SRI International, Menlo Park, CA 94025, USA.

    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program; if not, write to the Free Software
    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA.

)

---
---	Maude LTL satisfiability solver and model checker.
---	Version 2.3.
---

fmod LTL is
  protecting BOOL .
  sort Formula .

  --- primitive LTL operators
  ops True False : -> Formula [ctor format (g o)] .
  op ~_ : Formula -> Formula [ctor prec 53 format (r o d)] .
  op _/\_ : Formula Formula -> Formula [comm ctor gather (E e) prec 55 format (d r o d)] .
  op _\/_ : Formula Formula -> Formula [comm ctor gather (E e) prec 59 format (d r o d)] .
  op O_ : Formula -> Formula [ctor prec 53 format (r o d)] .
  op _U_ : Formula Formula -> Formula [ctor prec 63 format (d r o d)] .
  op _R_ : Formula Formula -> Formula [ctor prec 63 format (d r o d)] .

  --- defined LTL operators
  op _->_ : Formula Formula -> Formula [gather (e E) prec 65 format (d r o d)] .
  op _<->_ : Formula Formula -> Formula [prec 65 format (d r o d)] .
  op <>_ : Formula -> Formula [prec 53 format (r o d)] .
  op []_ : Formula -> Formula [prec 53 format (r d o d)] .
  op _W_ : Formula Formula -> Formula [prec 63 format (d r o d)] .
  op _|->_ : Formula Formula -> Formula [prec 63 format (d r o d)] . --- leads-to
  op _=>_ : Formula Formula -> Formula [gather (e E) prec 65 format (d r o d)] .
  op _<=>_ : Formula Formula -> Formula [prec 65 format (d r o d)] .

  vars f g : Formula .

  eq f -> g = ~ f \/ g .
  eq f <-> g = (f -> g) /\ (g -> f) .
  eq <> f = True U f .
  eq [] f = False R f .
  eq f W g = (f U g) \/ [] f .
  eq f |-> g = [](f -> (<> g)) .
  eq f => g = [] (f -> g) .
  eq f <=> g = [] (f <-> g) .

  --- negative normal form
  eq ~ True = False .
  eq ~ False = True .
  eq ~ ~ f = f .
  eq ~ (f \/ g) = ~ f /\ ~ g .
  eq ~ (f /\ g) = ~ f \/ ~ g .
  eq ~ O f = O ~ f .
  eq ~(f U g) = (~ f) R (~ g) .
  eq ~(f R g) = (~ f) U (~ g) .
endfm

fmod LTL-SIMPLIFIER is
  including LTL .

  --- The simplifier is based on:
  ---   Kousha Etessami and Gerard J. Holzman,
  ---   "Optimizing Buchi Automata", p153-167, CONCUR 2000, LNCS 1877.
  --- We use the Maude sort system to do much of the work.

  sorts TrueFormula FalseFormula PureFormula PE-Formula PU-Formula .
  subsort TrueFormula FalseFormula < PureFormula <
	  PE-Formula PU-Formula < Formula .

  op True : -> TrueFormula [ctor ditto] .
  op False : -> FalseFormula [ctor ditto] .
  op _/\_ : PE-Formula PE-Formula -> PE-Formula [ctor ditto] .
  op _/\_ : PU-Formula PU-Formula -> PU-Formula [ctor ditto] .
  op _/\_ : PureFormula PureFormula -> PureFormula [ctor ditto] .
  op _\/_ : PE-Formula PE-Formula -> PE-Formula [ctor ditto] .
  op _\/_ : PU-Formula PU-Formula -> PU-Formula [ctor ditto] .
  op _\/_ : PureFormula PureFormula -> PureFormula [ctor ditto] .
  op O_ : PE-Formula -> PE-Formula [ctor ditto] .
  op O_ : PU-Formula -> PU-Formula [ctor ditto] .
  op O_ : PureFormula -> PureFormula [ctor ditto] .
  op _U_ : PE-Formula PE-Formula -> PE-Formula [ctor ditto] .
  op _U_ : PU-Formula PU-Formula -> PU-Formula [ctor ditto] .
  op _U_ : PureFormula PureFormula -> PureFormula [ctor ditto] .
  op _U_ : TrueFormula Formula -> PE-Formula [ctor ditto] .
  op _U_ : TrueFormula PU-Formula -> PureFormula [ctor ditto] .
  op _R_ : PE-Formula PE-Formula -> PE-Formula [ctor ditto] .
  op _R_ : PU-Formula PU-Formula -> PU-Formula [ctor ditto] .
  op _R_ : PureFormula PureFormula -> PureFormula [ctor ditto] .
  op _R_ : FalseFormula Formula -> PU-Formula [ctor ditto] .
  op _R_ : FalseFormula PE-Formula -> PureFormula [ctor ditto] .

  vars p q r s : Formula .
  var pe : PE-Formula .
  var pu : PU-Formula .
  var pr : PureFormula .

  --- Rules 1, 2 and 3; each with its dual.
  eq (p U r) /\ (q U r) = (p /\ q) U r .
  eq (p R r) \/ (q R r) = (p \/ q) R r .
  eq (p U q) \/ (p U r) = p U (q \/ r) .
  eq (p R q) /\ (p R r) = p R (q /\ r) .
  eq True U (p U q) = True U q .
  eq False R (p R q) = False R q .

  --- Rules 4 and 5 do most of the work.
  eq p U pe = pe .
  eq p R pu = pu .

  --- An extra rule in the same style.
  eq O pr = pr .

  --- We also use the rules from:
  ---   Fabio Somenzi and Roderick Bloem,
  ---	"Efficient Buchi Automata from LTL Formulae",
  ---   p247-263, CAV 2000, LNCS 1633.
  --- that are not subsumed by the previous system.

  --- Four pairs of duals.
  eq O p /\ O q = O (p /\ q) .
  eq O p \/ O q = O (p \/ q) .
  eq O p U O q = O (p U q) .
  eq O p R O q = O (p R q) .
  eq True U O p = O (True U p) .
  eq False R O p = O (False R p) .
  eq (False R (True U p)) \/ (False R (True U q)) = False R (True U (p \/ q)) .
  eq (True U (False R p)) /\ (True U (False R q)) = True U (False R (p /\ q)) .

  --- <= relation on formula
  op _<=_ : Formula Formula -> Bool [prec 75] .

  eq p <= p = true .
  eq False <= p  = true .
  eq p <= True = true .

  ceq p <= (q /\ r) = true if (p <= q) /\ (p <= r) .
  ceq p <= (q \/ r) = true if p <= q .
  ceq (p /\ q) <= r = true if p <= r .
  ceq (p \/ q) <= r = true if (p <= r) /\ (q <= r) .

  ceq p <= (q U r) = true if p <= r .
  ceq (p R q) <= r = true if q <= r .
  ceq (p U q) <= r = true if (p <= r) /\ (q <= r) .
  ceq p <= (q R r) = true if (p <= q) /\ (p <= r) .
  ceq (p U q) <= (r U s) = true if (p <= r) /\ (q <= s) .
  ceq (p R q) <= (r R s) = true if (p <= r) /\ (q <= s) .

  --- condition rules depending on <= relation
  ceq p /\ q = p if p <= q .
  ceq p \/ q = q if p <= q .
  ceq p /\ q = False if p <= ~ q .
  ceq p \/ q = True if ~ p <= q .
  ceq p U q = q if p <= q .
  ceq p R q = q if q <= p .
  ceq p U q = True U q if p =/= True /\ ~ q <= p .
  ceq p R q = False R q if p =/= False /\ q <= ~ p .
  ceq p U (q U r) = q U r if p <= q .
  ceq p R (q R r) = q R r if q <= p .
endfm

fmod SAT-SOLVER is
  protecting LTL .

  --- formula lists and results
  sorts FormulaList SatSolveResult TautCheckResult .
  subsort Formula < FormulaList .
  subsort Bool < SatSolveResult TautCheckResult .
  op nil : -> FormulaList [ctor] .
  op _;_ : FormulaList FormulaList -> FormulaList [ctor assoc id: nil] .
  op model : FormulaList FormulaList -> SatSolveResult [ctor] .

  op satSolve : Formula ~> SatSolveResult
	[special (
	   id-hook SatSolverSymbol
	   op-hook trueSymbol           (True : ~> Formula)
	   op-hook falseSymbol		(False : ~> Formula)
	   op-hook notSymbol		(~_ : Formula ~> Formula)
	   op-hook nextSymbol		(O_ : Formula ~> Formula)
	   op-hook andSymbol		(_/\_ : Formula Formula ~> Formula)
	   op-hook orSymbol		(_\/_ : Formula Formula ~> Formula)
	   op-hook untilSymbol		(_U_ : Formula Formula ~> Formula)
	   op-hook releaseSymbol	(_R_ : Formula Formula ~> Formula)
	   op-hook formulaListSymbol
		   (_;_ : FormulaList FormulaList ~> FormulaList)
	   op-hook nilFormulaListSymbol	(nil : ~> FormulaList)
	   op-hook modelSymbol
		   (model : FormulaList FormulaList ~> SatSolveResult)
	   term-hook falseTerm		(false)
	 )] .

  op counterexample : FormulaList FormulaList -> TautCheckResult [ctor] .
  op tautCheck : Formula ~> TautCheckResult .
  op $invert : SatSolveResult -> TautCheckResult .

  var F : Formula .
  vars L C : FormulaList .
  eq tautCheck(F) = $invert(satSolve(~ F)) .
  eq $invert(false) = true .
  eq $invert(model(L, C)) = counterexample(L, C) .
endfm

fmod SATISFACTION is
  protecting BOOL .
  sorts State Prop .
  op _|=_ : State Prop -> Bool [frozen] .
endfm

fmod MODEL-CHECKER is
  protecting QID .
  including SATISFACTION .
  including LTL .
  subsort Prop < Formula .

  --- transitions and results
  sorts RuleName Transition TransitionList ModelCheckResult .
  subsort Qid < RuleName .
  subsort Transition < TransitionList .
  subsort Bool < ModelCheckResult .
  ops unlabeled deadlock : -> RuleName .
  op {_,_} : State RuleName -> Transition [ctor] .
  op nil : -> TransitionList [ctor] .
  op __ : TransitionList TransitionList -> TransitionList [ctor assoc id: nil] .
  op counterexample : TransitionList TransitionList -> ModelCheckResult [ctor] .

  op modelCheck : State Formula ~> ModelCheckResult
	[special (
	   id-hook ModelCheckerSymbol
	   op-hook trueSymbol           (True : ~> Formula)
	   op-hook falseSymbol		(False : ~> Formula)
	   op-hook notSymbol		(~_ : Formula ~> Formula)
	   op-hook nextSymbol		(O_ : Formula ~> Formula)
	   op-hook andSymbol		(_/\_ : Formula Formula ~> Formula)
	   op-hook orSymbol		(_\/_ : Formula Formula ~> Formula)
	   op-hook untilSymbol		(_U_ : Formula Formula ~> Formula)
	   op-hook releaseSymbol	(_R_ : Formula Formula ~> Formula)
           op-hook satisfiesSymbol      (_|=_ : State Formula ~> Bool)
	   op-hook qidSymbol		(<Qids> : ~> Qid)
	   op-hook unlabeledSymbol	(unlabeled : ~> RuleName)
	   op-hook deadlockSymbol	(deadlock : ~> RuleName)
	   op-hook transitionSymbol	({_,_} : State RuleName ~> Transition)
	   op-hook transitionListSymbol
		   (__ : TransitionList TransitionList ~> TransitionList)
	   op-hook nilTransitionListSymbol	(nil : ~> TransitionList)
	   op-hook counterexampleSymbol
		   (counterexample : TransitionList TransitionList ~> ModelCheckResult)
	   term-hook trueTerm		(true)
	 )] .
endfm

-----------------------------------
--- END OF MODEL-CHECKER MODULE ---
-----------------------------------

mod INITIAL is inc STRING + INT + QID .

  op NHISTORY : -> Int .
  eq [NHISTORY] : NHISTORY = 10 .
  
  op IS-HISTORY : -> Bool .
  eq [IS-HISTORY] : IS-HISTORY = true .
  
endm


mod TYPES is inc INITIAL .

 sorts Value Id .
 subsorts  Int < Value .
  
 vars v1 v2 : Value .
 vars s1 s2 : String .
 vars n i1 i2 : Int .
 vars b1 b2 : Bool .
 vars id id1 id2 : Id . 

 op _._ : Id Int -> Id [ctor] .

 op newid : Id Int -> Id  [ctor] .
 eq [newid] : newid ( id1  , n) =   id1 . n .


 op null : -> Value [ctor] .
 op i_ : Int -> Value [ctor] .
 op s`(_`) : String -> Value [ctor] .
 op b_ : Bool -> Value [ctor] .
 
 op _v+_ : Value Value -> Value .
 eq  [a1] : ( s(s1) v+ s(s2) ) = s( s1 + s2 ) .
 eq  [a2] : ( i(i1) v+ i(i2) ) = i( i1 + i2 ) .
 eq  [a3] : v1 v+ v2 = v1 + v2 [owise] .

 op string : Id -> String .
 eq [st] : string (id) = "id" . 
  
endm


mod DATABASE is inc TYPES .

 sorts DB SqlDB  ValueDB .
 subsorts Value < SqlDB .
 subsorts Value < ValueDB .
 
 op sql-empty : -> SqlDB [ctor] .
 
 op valueDB-empty : -> ValueDB [ctor] .

 op _:_ : ValueDB ValueDB -> ValueDB [ctor assoc id: null] . 
 
 op `(_;_`) : SqlDB Value -> DB [ctor] .
 op db-empty : -> DB [ctor] .
 op __ : DB DB -> DB [ctor assoc comm id: db-empty] . 

 vars sql : SqlDB .
 vars v v1 v2 : Value .
 vars db dbs : DB .
 
 op select : DB SqlDB -> ValueDB .
 eq [select1] : select ((sql ; v) dbs , sql ) = v : (select ( dbs , sql )  ) . 
 eq [select2] : select (dbs , sql ) = null [owise] . 
 
 op update : DB SqlDB ValueDB -> DB .
 eq [update1] : update ((sql ; v1) dbs, sql, v2) = (sql ; v2) dbs .
 eq [update2] : update ( db, sql, v) = (sql ; v) db [owise] .

 op insert : DB SqlDB ValueDB -> DB .
 eq [insert1] : insert ( db, sql, v) = (sql ; v) db .

endm


mod SESSION is inc TYPES .

 sorts Session UserSession . --- Name Value .
 
 vars n : Value .
 vars s ss : Session .
 vars v v1 v2 : Value .
 
 op `(_`,_`) : Value Value -> Session [ctor] .
 op session-empty : -> Session [ctor] .
 op _:_ : Session Session -> Session [ctor assoc comm id: session-empty] .

 op _in_ : Value Session -> Bool .
 eq [aux1] : n in ((n , v) : ss) = true .
 eq [aux2] : n in  s = false [owise] . 
 
 op getSessionValue : Session Value -> Value .
 eq [getSessionValue1] : getSessionValue( ((n , v) : ss) , n ) = v .
 eq [getSessionValue2] : getSessionValue( s , n ) = null [owise] .

 op setSessionValue : Session Value Value -> Session .
 eq [getSessionValue3] : setSessionValue( ((n , v1) : ss) , n , v2 ) = ((n , v2) : ss) .
 eq [getSessionValue4] : setSessionValue( s , n , v ) = ((n , v) : s) [owise] .
 
 op us`(_`,_`) : Id Session -> UserSession [ctor]  .
 op usersession-empty : -> UserSession [ctor]  .
 op _:_ : UserSession UserSession -> UserSession [ctor assoc comm id: usersession-empty] .
 
endm


mod QUERY is inc TYPES .

 sorts Query Sigma Name  .

 vars n : Qid .
 vars v w : String .
 vars q qs : Query .
 vars z zs : Sigma .
 
 op _'=_ : Qid String -> Query [ctor] .
 op query-empty : -> Query [ctor] .
 op _:_ : Query Query -> Query [ctor assoc comm id: query-empty] .

 op _in_ : Qid Query -> Bool .
 eq [aux5] : n in ((n '= v) : qs) = true .
 eq [aux6] : n in  q = false [owise] .

 op _/_ : Qid String -> Sigma [ctor] .
 op sigma-empty : -> Sigma [ctor] .
 op _:_ : Sigma Sigma -> Sigma [ctor assoc comm id: sigma-empty] .

 op sigma : Sigma Query -> Query .
 eq [sigma1] : sigma ( ( (n / v) : zs) , ( (n '= w) : qs) )  =  (( n '= v ) : ( sigma ( ((n / v) : zs) , qs ) )) . 
 eq [sigma2] : sigma (zs, qs) =  qs  [owise] .

endm


mod MEMORY is inc TYPES . 
    sorts Memory  .

    op none : -> Memory [ctor] .
    op _:_ : Memory Memory -> Memory [ctor assoc comm id: none] .
    op `[_`,_`] : Qid Value -> Memory [ctor] .
    op _in_ : Qid Memory -> Bool .
    
	var q : Qid . 
	var m : Memory . 
	var v : Value .
    
    eq [axx3] : q in [q,v] : m = true .
    eq [axx5] : q in  m = false [owise] .
	
endm


mod EXPRESSION is inc MEMORY  + QUERY + SESSION + DATABASE .
  sorts Expression Test .
  subsorts Test Value Qid < Expression .
  
  vars ex ex1 ex2 ex3 ex4 : Expression .
  vars b66 : Bool .
  vars m ms  : Memory .
  vars db dbs : DB .
  vars s ss : Session .
  vars q qs : Query .
  vars x y : Int .
  vars qid : Qid .
  vars v  : Value .
  vars str : String .
  vars sql : SqlDB .
  vars t : Test .
  
  op TRUE : -> Test .
  op FALSE : -> Test .
  
  op _=_  : Expression Expression -> Test .
  op _!=_  : Expression Expression -> Test .
  
  op _'+_ : Expression Expression -> Expression .
  op _'*_ : Expression Expression -> Expression .
  op _'._ : Expression Expression -> Expression .

  --- The expression, memory, session, query, bada base
  op eval : Expression Memory Session Query DB -> Expression  .
  eq [eval1] : eval ( v , m , s , q , db ) = v .
  eq [eval2] : eval ( ex , m , s , q , db ) = null [owise] .

  ceq [eval3] : eval ( ex1 = ex2 , m , s, q, db ) = TRUE      if ex3 := eval(ex1, m, s, q, db) /\ ex4 := eval(ex2, m, s, q, db) /\ ex3 == ex4  .
  ceq [eval4] : eval ( ex1 = ex2 , m , s, q, db ) = FALSE     if ex3 := eval(ex1, m, s, q, db) /\ ex4 := eval(ex2, m, s, q, db) /\ ex3 =/= ex4  .

  ceq [eval5] : eval ( ex1 != ex2 , m , s, q, db ) = FALSE    if ex3 := eval(ex1, m, s, q, db) /\ ex4 := eval(ex2, m, s, q, db) /\ ex3 == ex4  .
  ceq [eval6] : eval ( ex1 != ex2 , m , s, q, db ) = TRUE     if ex3 := eval(ex1, m, s, q, db) /\ ex4 := eval(ex2, m, s, q, db) /\ ex3 =/= ex4  .

  eq  [eval7] : eval ( qid , ([qid, v] : ms), s, q , db ) = v .
  ceq [eval8] : eval ( qid ,  m, s, q, db ) = null   if b66 := qid in m /\ b66 =/= true .

  eq [eval9] : eval ( ex1 '+ ex2 , m , s, q, db ) = eval(ex1, m, s, q, db) + eval(ex2, m, s, q, db) .
  eq [eval10] : eval ( ex1 '* ex2 , m , s, q, db ) = eval(ex1, m, s, q, db) * eval(ex2, m, s, q, db) .
  eq [eval11] : eval ( ex1 '. ex2 , m , s, q, db ) = eval(ex1, m, s, q, db) v+ eval(ex2, m, s, q, db) .

  ----- extended for the web --------------------
  op getSession : Expression -> Expression  .
  op getQuery : Qid -> Expression .

  eq [eval12] :  eval ( getSession(ex) , m , s , q, db ) =  getSessionValue( s, eval(ex, m, s, q, db) )  .  

  eq  [eval13] : eval ( getQuery(qid) , m , s , (qid '= str) : qs , db ) = s(str) .  
  ceq [eval14] : eval ( getQuery(qid) , m ,  s , q , db ) = null  if b66 := qid in q /\ b66 =/= true .
    
  ----- extended for persistente information
  op selectDB : Expression -> Expression .

  eq  [eval15] : eval ( selectDB(ex) , m ,  s , q, db ) = select(db,  eval(ex, m, s, q, db)) .  

endm


mod SCRIPT is inc EXPRESSION .
  
 sorts Script ScriptState .
 
 op skip : -> Script .
 op _;_ : Script Script -> Script [prec 61 assoc id: skip] .
 op _:=_ : Qid Expression -> Script .  
 op if_then_else_fi : Test Script Script -> Script .
 op if_then_fi : Test Script -> Script .
 op while_do_od : Test Script -> Script .
 op repeat_until_od : Script Test -> Script .

 op `[_`,_`,_`,_`,_`] :  Script Memory Session Query DB  -> ScriptState .


 vars ex ex1 ex2 : Expression .
 vars m ms  : Memory .
 vars b66 : Bool .
 vars db dbs : DB .
 vars s ss : Session .
 vars q qs : Query .
 vars x y : Int .
 vars qid : Qid .
 vars v  : Value .
 vars str : String .
 vars p p1 p2 ps : Script .
 vars t : Test .
 vars sql : SqlDB .

 op eval : ScriptState -> ScriptState .
 
 --- skip - stop the eval
 eq [eval15] : eval ( [ skip , m , s , q , db ] ) = [ skip , m , s , q , db ] .
 eq [eval16] : eval ( [ p , m , s , q , db ] ) = [ p , m , s , q , db ] [owise] .

 --- :=
 eq [eval17] : eval ( [ (qid := ex ); ps , [qid, v] : ms, s, q , db ] ) =
                 eval ( [ ps , [qid, eval(ex, [qid, v] : ms, s, q , db ) ] : ms, s, q , db ] ) . 
 ceq [eval18] : eval ( [ (qid := ex ); ps ,  ms, s, q , db ] ) =
                 eval ( [ ps , [qid, eval(ex, ms, s, q, db ) ] : ms, s, q, db ] ) if b66 := qid in ms /\ b66 =/= true . 

 --- if then else fi
 ceq [eval19] : eval ( [ ( if t then p1 else p2 fi ) ; ps , m, s, q , db ] ) =
                 eval ([ p1 ; ps , m, s, q, db ])     if TRUE := eval(t, m, s, q, db) .

 ceq [eval20] : eval ( [ ( if t then p1 else p2 fi ) ; ps , m, s, q , db ] ) =
                 eval ([ p2 ; ps , m, s, q, db ])     if FALSE == eval(t, m, s, q, db) .


 --- if then  fi
 eq [eval21] : eval ( [ ( if t then p fi ); ps , m, s, q , db ] ) =
                 eval ([ ( if t then p else skip fi ) ; ps , m, s, q, db ]) .				 
				 
 --- while do od
 ceq [eval22] : eval ( [ ( while t do p od ); ps , m, s, q , db ] ) =
                 eval ([ p ; while t do p od ; ps , m, s, q, db ])  if  TRUE := eval(t, m, s, q, db) .
 ceq [eval23] : eval ( [ ( while t do p od ); ps , m, s, q , db ] ) =
                 eval ([  ps , m, s, q, db ])  if  FALSE := eval(t, m, s, q, db) .
				 

				 
 --- repeat until od
 eq [eval24] : eval ( [ ( repeat p until t od ); ps , m, s, q , db ] ) =
                 eval ([  p ; (while t do p od) ; ps , m, s, q, db ])  .

 
  --- extended for the web
 op setSession : Expression Expression -> Script .
 op clearSession : -> Script .
 
 eq [eval25] : eval ([ ( setSession(ex1, ex2) ); ps , m, s , q , db ]) =  
                 eval ([ ps , m, setSessionValue (s , eval(ex1, m, s, q, db) ,  eval(ex2, m, s, q, db) )  , q , db ])  .
 
 eq [eval26] : eval ([ clearSession ; ps , m, s , q , db ]) = 
                 eval ([ ps , m, session-empty , q , db ])  .
 
 
 ----- extended for persistente information
 op updateDB : Expression Expression -> Script .
 eq [eval27] : eval ([ ( updateDB (ex1, ex2) ); ps , m, s , q , db ]) = 
                 eval ([ ps , m, s , q , update (db, eval(ex1, m, s, q, db) ,  eval(ex2, m, s, q, db) ) ])  .

endm


mod CONDITION is inc TYPES + SESSION .

 sorts Condition . --- Name Value .

 vars c cs : Condition .
 vars s ss : Session .
 vars n : Value .
 vars v v1 v2 : Value .

 op TRUE  : -> Condition [ctor] . 
 op FALSE : -> Condition [ctor] . 
 op cond-empty : -> Condition [ctor] .
 op _'==_ : Value Value -> Condition [ctor] .
 op _:_ : Condition Condition -> Condition [ctor assoc comm id: cond-empty] .
 
 op holdCondition : Condition Session -> Bool .
 eq [holdCondition1] : holdCondition( cond-empty , s ) = true  .   
 eq [holdCondition2] : holdCondition( TRUE , s ) = true  .   
 eq [holdCondition3] : holdCondition( FALSE , s ) = false  .   
 eq [holdCondition4] : holdCondition( (n '== v) : cs , ( n , v ) : ss ) =  holdCondition(cs, ss) .   --- is the case of n=v in the session
 eq [holdCondition5] : holdCondition( c , s ) = false [owise]  .   

endm


mod WEB_MODEL is inc SCRIPT + CONDITION  .
   pr SET{Qid} .

 sorts Page URL Continuation Navigation Browser Server Message ReadyMessage History .

 vars id idw : Id .
 vars z : Sigma .
 vars np np1 np2 : Qid .
 vars q : Query .
 vars sc : Script .
 vars wapps : Page .
 vars cont : Continuation .
 vars nav : Navigation .
 vars nat : Nat .
 vars h hs : History . 
 vars url url1 url2 : URL .
 vars m m1 m2 : Message .
 vars s : Session .

--------------------
--- URL  -----------
 --- Page name , query .
 op _?_ : Qid Query -> URL [ctor] .
 op url-empty : -> URL [ctor] .
 op _:_ : URL URL -> URL [ctor assoc comm id: url-empty] .

--------------------
--- Continuation ---
 --- condition , page name .
 op `(_=>_`) : Condition Qid -> Continuation [ctor] .
 op cont-empty : -> Continuation .
 op _:_ : Continuation Continuation -> Continuation [ctor assoc comm id: cont-empty] .

--------------------
--- Navigation -----
 op `(_->_`) : Condition URL -> Navigation [ctor] .
 op nav-empty : -> Navigation .
 op _:_ : Navigation Navigation -> Navigation [ctor assoc comm id: nav-empty] .

--------------------
--- WebPage --------
 --- Name, script, continuation, navigation .
 op `(_`,_`,`{_`}`,`{_`}`) : Qid Script Continuation Navigation -> Page [ctor] . 
 op page-empty : -> Page .
 op _:_ : Page Page -> Page [ctor assoc comm id: page-empty] .
 
 op pageNotFound : -> Qid .

 op notFoundPage : -> Page .
 eq notFoundPage = ( pageNotFound,
                     skip,
                     {cont-empty},
                     {nav-empty} ) .
 
--------------------
--- History --------

 op H : Qid URL Message -> History [ctor] .
 op history-empty : -> History [ctor] .
 op __ : History History -> History [ctor assoc id: history-empty] .
 op _:_ : History History -> History . --- [ctor assoc id: history-empty] .

 op long : History -> Int .
 eq [long1] : long (history-empty) = 0 .
 eq [long2] : long ( H(np,url,m) : h ) = 1 + long(h) .

 ceq [hc] : H(np1,url1,m1) : (hs H(np2,url2,m2)) =  H(np1,url1,m2) hs   if long(hs) = NHISTORY .
 eq [h] : h : hs =  h hs  [owise] .

--------------------
--- Browser --------
 --- IdBrowser, IdWindows, NamePage, Urls, Session Database LastMessage History  IdLastMes
 op B : Id Id Qid URL Session Sigma Message History Nat -> Browser [ctor] .
 op br-empty : -> Browser .
 op _:_ : Browser Browser -> Browser [ctor assoc comm id: br-empty] .

 op PageNameEmpty : -> Qid .
 eq [PageNameEmpty] : PageNameEmpty = 'PageNameEmpty .
 
 op URLEmpty : -> URL  . 
 
 op brEmpty : Id Id Sigma -> Browser .
 eq [brEmpty] : brEmpty (id, idw, z) = B( id, idw, 'PageNameEmpty, url-empty, session-empty, z, mes-empty , history-empty , 1) .

 op noPage : -> Qid .
 eq [noPage] : noPage = 'noPage .
 
 op newBrowser : Id Id URL Sigma -> Browser .
 eq [newBrowser] : newBrowser (id, idw, (np ? q), z) = B(id, idw, noPage, (np ? q), session-empty, z, mes-empty, history-empty, 1) .

--------------------
--- Message --------
 op m : Id Id URL Nat -> Message [ctor] .                   --- message to server
 op m : Id Id Qid URL Session Nat -> Message [ctor] .            --- message to browser
 op mes-empty : -> Message .
 op _:_ : Message Message -> Message [ctor assoc  id: mes-empty] .

--------------------
--- ReadyMessage ---
 op rm : Message Session DB -> ReadyMessage [ctor] .
 op readymes-empty : -> ReadyMessage .
 op _:_ : ReadyMessage ReadyMessage -> ReadyMessage [ctor assoc  id: readymes-empty] .

--------------------
--- Server ---------
 op S : Page UserSession Message ReadyMessage DB -> Server [ctor] .

--------------------
--- auxiliary operations

  op allWebPages : Page -> Set{Qid} .
---  eq allWebPages (page-empty) = empty .
  eq [allWebPages1] : allWebPages (page-empty) = insert( noPage , ( insert( 'PageNameEmpty, empty) ) )  .
  eq [allWebPages2] : allWebPages (( np , sc , { cont } , { nav } ) : wapps ) = insert( np, allWebPages ( wapps ) ) .
 
endm


mod EVAL is inc WEB_MODEL  .
  
  vars page wapp wapps w : Page .
  vars np qid np1 np2 nextPage : Qid .
  vars q q1 : Query . 
  vars sc sc1 : Script .
  vars cont conts : Continuation .
  vars nav : Navigation .
  vars ss nextS : Session .
  vars cond conds : Condition .
  vars url urls nextURLs : URL .
  vars id idw : Id .
  vars uss : UserSession .
  vars db nextDB : DB .
  vars m : Memory .
  vars idmes : Nat .
  
  op pageNotContinuaton : -> Qid .
  
  --- eval the continuation    
  op  holdContinuation : Qid Continuation Session -> Qid .
  eq  [holdContinuation1] : holdContinuation(np, cont-empty, ss) = np .
  eq  [holdContinuation2] : holdContinuation(np, (cond => np) : conts, ss) = holdCont (np, (cond => np) : conts , ss) .
  ceq [holdContinuation3] : holdContinuation(np, conts, ss) = qid
                        if np1 :=  holdCont (np, conts , ss) /\ 
						   qid := whichQid ( np , np1 ) [owise] .
  
  op  holdCont : Qid Continuation Session -> Qid .
  eq  [holdCont1] : holdCont (np, cont-empty, ss) = pageNotContinuaton .
  ceq [holdCont2] : holdCont (np, (cond => qid) : conts, ss) = qid  if ( holdCondition(cond,ss) ) .
  eq  [holdCont3] : holdCont (np, (cond => qid) : conts, ss) = holdCont (np, conts, ss) [owise] .


  op whichQid : Qid Qid -> Qid .
  eq [whichQid1] : whichQid ( np , pageNotContinuaton ) = np .
  eq [whichQid2] : whichQid ( np , np1 ) = np1 [owise] .

  
  --- eval the navegation 
  op holdNavigation : Qid Page Session -> URL .
  eq [holdNavigation1] : holdNavigation(np , (( np , sc , { cont } , { nav } ) : wapp ), ss  ) = getURLs (nav, ss) .
  eq [holdNavigation2] : holdNavigation(np ,  wapp , ss  ) = url-empty [owise] .

  
  op  getURLs : Navigation Session -> URL .
  eq  [getURLs1] : getURLs ( nav-empty , ss ) = url-empty .
  ceq [getURLs2] : getURLs ( ( cond -> url) : nav , ss ) = url : getURLs ( nav , ss )   if ( holdCondition(cond,ss) ) .
  eq  [getURLs3] : getURLs ( ( cond -> url) : nav , ss ) = getURLs ( nav , ss )  [owise] .


  --- eval the script    
  op  evalScript : Page UserSession Message DB -> ReadyMessage .
  ceq [evalScript1] : evalScript (
         (( np , sc , { cont } , { nav } ) : wapps ) ,
		 us( id, ss ) : uss ,
		 m( id , idw , (np ? q) , idmes ) ,
		 db  
      )  = rm( m( id, idw, nextPage, nextURLs, nextS, idmes), nextS, nextDB) 
			if 
			   [sc1, m, nextS, q1, nextDB] := eval([sc, none, ss, q, db] )  /\
			   nextPage := holdContinuation (np, cont, nextS)               /\
			   nextURLs := holdNavigation (nextPage, (( np , sc , { cont } , { nav } ) : wapps ) , nextS) 
	  .
	  
  eq [evalScript2] : evalScript ( wapp , us( id, ss ) : uss , m( id, idw, (np ? q), idmes ) , db  )  = 
                            rm( m( id, idw, pageNotFound, url-empty, ss, idmes ), ss, db ) [owise] .
				  
endm


mod BROWSER-ACTION is inc INT + QID .
 
 sorts BrowserActions Tab .

 vars np : Qid .
 vars ba : BrowserActions .
 vars ln tab f5 : Qid .

 op T : Int Qid -> Tab [ctor] .
 op tab-empty : -> Tab .
 op _;_ : Tab Tab -> Tab [ctor assoc comm id: tab-empty] .
 
 op f5-empty : -> Qid . 
 op _;_ : Qid Qid -> Qid [ctor assoc comm id: f5-empty] . 

 op bra-empty :  -> BrowserActions . 
 op BA : Tab Qid -> BrowserActions [ctor] .

endm


mod PROTOCOL is inc WEB_MODEL + EVAL + BROWSER-ACTION .

 sorts WebState .
 
 op `[_`]_`[_`]`[_`] : Browser BrowserActions Message Server -> WebState [ctor] .

 vars id idw : Id .
 vars p wapp : Page .
 vars np np1 np2 f5 : Qid .
 vars q q1 : Query .
 vars z : Sigma .
 vars urls urls1 urls2 : URL .
 vars ms ms1 pms lms : Message .
 vars rms : ReadyMessage .
 vars sv : Server .
 vars ss ss1 ss2 : Session .
 vars uss : UserSession .
 vars brs : Browser .
 vars db : DB .
 vars h : History .
 vars idlm idlm1 idlm2 : Nat .
 vars ba : BrowserActions .
 vars n : Int .
 vars tab : Tab .

  op evalScriptRM : -> ReadyMessage .
  op block-db : -> DB [ctor] .

  op createUserSession : Id Server -> Server .
  eq [createUserSession1] : createUserSession (id , S(wapp , us( id, ss ) : uss  ,  pms , rms, db)  ) =  
                                 S(wapp , us( id, ss ) : uss  ,  pms , rms, db ) .

  eq [createUserSession2] : createUserSession (id , S(wapp , uss  ,  pms , rms, db)  ) =  
                                 S(wapp , us( id, session-empty ) : uss  ,  pms , rms, db ) [owise] .

--------------------------------------------------------
--- definition of the protocol request-response --------


--- request.click
--- browser submit a request to the server.

 rl [createSession] : [ B(id, idw, np, (np1 ? q1) : urls, ss, z, lms, h, idlm) : brs ] ba
		      [ ms ]
		      [ S(wapp , usersession-empty ,  pms , rms, db ) ]
		=>
		      [ B(id, idw, np, (np1 ? q1) : urls, ss, z, lms, h, idlm) : brs ] ba
		      [ ms ]
		      [ S(wapp , us( id, session-empty ) ,  pms , rms, db ) ]
		.

 rl [ReqIni] : [ B(id, idw, np, (np1 ? q1) : urls, ss, z, lms, h, idlm) : brs ] ba
               [ ms ]
			   [ sv ]	 
		=>  
		       [  B( id, idw, 'PageNameEmpty, url-empty , ss, z, 
			      m( id, idw, (np1 ? (sigma(z,q1) )) , idlm ) ,     --- new last message 
				  h ,                                               --- history
				  idlm
				 ) 
				 : brs ] ba
		       [ ms : m( id, idw, (np1 ? (sigma(z,q1) )), idlm  )  ]
			   [ sv ] .

--- request.read
--- the server read the message and add to the set of pending messages.
 rl [ReqFin] : 
           [ brs ] ba
		   [ m(id, idw, urls, idlm) : ms ]
	       [ S(wapp , uss , pms, rms, db) ]
		=>
		   [ brs ] ba
		   [ ms ]
		   [ S(wapp , uss , pms :  m(id, idw, urls, idlm)  , rms , db) ] .

--- eval script 
--- read a pending message and running the script, and then add to set of ready messages.
 rl [ScriptEval] : 
	  [ brs ] ba
           [ ms ] 
		   [ S(wapp , uss , m(id, idw, urls, idlm) : pms ,  rms, db) ]
		=>
           [ brs ] ba
		   [ ms ]
		   [ S(wapp , uss , pms , rms : evalScript (wapp , us( id, session-empty ), m(id, idw, urls, idlm) , db ) , block-db ) ] .

--- response
--- the server update the session of browser and db, then  sent a (pending) message to the browser.
 rl [ResIni] : 
          [ brs ] ba
	      [ ms ]
		  [ S(wapp , us( id, ss1 ) : uss , pms , rm(m( id, idw, np , urls, ss2, idlm), ss2, db)  : rms , block-db ) ] 
		=>
		  [ brs ] ba
	      [ ms :  m( id, idw, np , urls, ss2, idlm) ]
	      [ S(wapp , us( id, ss2 ) : uss , pms , rms , db ) ] .

--- response
--- the browser read a message for selft and show the page.
 rl [ResFin] : 
          [ B(id, idw, np1, urls1, ss, z, lms, h, idlm1 ) : brs ] ba
	      [ m(id, idw, np2, urls2, ss2, idlm1) : ms ]
	      [ sv ] 
		=>
	      [ B(id, idw, np2, urls2, ss2, z, lms, h, idlm1) : brs ] ba
	      [ ms ]
		  [ sv ] . 

--- is not the last message, make a top 
 rl [ResFinNo] : 
          [ B(id, idw, np1, urls1, ss, z, lms, h, idlm1) : brs ] ba
          [ m(id, idw, np2, urls2, ss2, idlm2) : ms ]
		  [ sv ] 
		=>
	      [ B(id, idw, np1, urls1, ss, z, lms, h, idlm1) : brs ] ba
	      [ ms ]
          [ sv ] .

--------------------------------------------------------
--- operations of browser ------------------------------

--- new tab
  rl [newT] : 
          [ B(id, idw, np,  urls, ss, z, lms, h, idlm) : brs ]  BA( ( T(n,np) ; tab), f5 )
         [ ms ]
	     [ sv ]	 
	       =>
		 [ B(id, idw, np,  urls, ss, z, lms, h, idlm ) : 
		   B(id, newid(idw,n), np,  urls, ss, z, mes-empty, history-empty, idlm )  : 
		   brs ]  BA( tab , f5 )
		 [ ms ]
		 [ sv ]	
		.

--- refresh F5
 rl [F5] :
             [ B(id, idw, np,  urls, ss, z, m(id, idw, urls, idlm), h, idlm) : brs ] BA( tab, (np ; f5) )
		 [ ms ]
		 [ sv ]	 
	       =>
	     [ B(id, idw, np,  urls, ss, z, m(id, idw, urls, (idlm + 1) ), h, (idlm + 1) ) : brs ] BA( tab, f5 )
		 [ ms : m(id, idw, urls, (idlm + 1) ) ]
		 [ sv ]	
		.
 
endm


mod WEBAPP is inc PROTOCOL .

 -------------------------------------------------------------------------
 -------------------------------------------------------------------------
 --- Webmail Application
 -------------------------------------------------------------------------
 -------------------------------------------------------------------------

 ops WELCOME HOME EMAIL-LIST VIEW-EMAIL CHANGE-ACCOUNT ADMINISTRATION ADMIN-LOGOUT LOGOUT : -> Qid .
 eq [WELCOME] : WELCOME = 'Welcome .
 eq [HOME] : HOME = 'Home . 
 eq [EMAIL-LIST] : EMAIL-LIST = 'Email-list .
 eq [VIEW-EMAIL] : VIEW-EMAIL = 'View-email .
 eq [CHANGE-ACCOUNT] : CHANGE-ACCOUNT = 'Change-account .
 eq [ADMINISTRATION] : ADMINISTRATION = 'Administration .
 eq [ADMIN-LOGOUT] : ADMIN-LOGOUT = 'Admin-Logout .
 eq [LOGOUT] : LOGOUT = 'Logout .
 
 -------------------------------------------------------------------------
 --- Welcome page
 op welcomePage : -> Page .
 eq [welcomePage] : welcomePage = ( WELCOME , skip , 
                   { cont-empty } , 
                   { ( TRUE  -> ( HOME ? ('user '= "") : ('pass '= "")  ) ) } ) .

 -------------------------------------------------------------------------
 --- Home page
 op homePage : -> Page .
 eq [homePage] : homePage = ( HOME , sHome , { (( s("login") '== s("no") ) => WELCOME ) : 
                                  (( s("changeLogin") '== s("no") ) => CHANGE-ACCOUNT ) : 
                                  (( s("login") '== s("ok") ) => HOME )								  
								} , 
                                { (TRUE -> CHANGE-ACCOUNT ? query-empty ) :
								  (( s("role") '== s("admin") )  -> ( ADMINISTRATION ? query-empty  ) ) : 
								  (TRUE -> EMAIL-LIST ? query-empty ) :
								  (TRUE -> LOGOUT ? query-empty )
								} ) .


 op sHome : -> Script .
 eq [sHome] : sHome = 
       'login := getSession( s("login") ) ;
	  if ( 'login = null ) then 
         'u := getQuery('user) ;
	     'p := getQuery('pass) ;
	     'p1 := selectDB('u) ;
	     if ( 'p = 'p1 ) then
	        'r := selectDB('u '. s("-role") ) ;
	        setSession( s("user") , 'u ) ; 
		    setSession( s("role") , 'r ) ; 
		    setSession( s("login") , s("ok") ) 
	     else
	        setSession( s("login") , s("no") )
	     fi
	   fi
	   .

 -------------------------------------------------------------------------
 --- EmailList page
 op emailListPage : -> Page .
 eq [emailListPage] : emailListPage = ( EMAIL-LIST , sEmailList , 
                     { cont-empty } , 
                     { ( TRUE  -> ( VIEW-EMAIL ? ('idEmail '= "") ) ) :
					   ( TRUE  -> ( HOME ? query-empty ) ) 
					  } ) .

 op sEmailList : -> Script .
 eq [sEmailList] : sEmailList = 
        'u  := getSession(s("user")) ;
		'es := selectDB( 'u '. s("-email") ) ;
		setSession( s("idEmails-found") , 'es )
		.


 -------------------------------------------------------------------------
 --- View email page
 op viewEmailPage : -> Page .
 eq [viewEmailPage] : viewEmailPage = ( VIEW-EMAIL , sViewEmail , 
                     { cont-empty } , 
                     { ( TRUE  -> ( EMAIL-LIST ? query-empty ) ) :
					   ( TRUE  -> ( HOME ? query-empty ) ) 
					  } ) .
 
 op sViewEmail : -> Script .
 eq [sViewEmail] : sViewEmail = 
        'u := getSession(s("user")) ;
		'id := getQuery('idEmail) ;
		'e := selectDB('id ) ;
		setSession( s("text-email") , 'e )
		.
 
 -------------------------------------------------------------------------
 --- Change account page
 op changeAccountPage : -> Page .
 eq [changeAccountPage] : changeAccountPage = ( CHANGE-ACCOUNT , skip , 
                        { cont-empty } , 
                        { ( TRUE  -> ( HOME ? ('newUser '= "") : ('newPass '= "") ) ) } ) .
						
 -------------------------------------------------------------------------
 --- Administration page
 op administrationPage : -> Page .
 eq [administrationPage] : administrationPage = ( ADMINISTRATION , sAdministration , 
                                 { (( s("adminPage") '== s("busy") ) => HOME ) } , 
								 { ( TRUE  -> ( ADMIN-LOGOUT ? query-empty ) ) } ) .

 op sAdministration : -> Script .
 eq [sAdministration] : sAdministration = 
        'adminPage := selectDB( s("adminPage") ) ;
		if ('adminPage = s("free") )  then
             updateDB(s("adminPage") , getSession(s("user")) );
		     setSession(s("adminPage") , s("free") ) 		
		else
		     setSession(s("adminPage") , s("busy") ) 	
		fi
		.

 -------------------------------------------------------------------------
 --- Admin logout page
 op adminLogoutPage : -> Page .
 eq [adminLogoutPage] : adminLogoutPage = ( ADMIN-LOGOUT , sAdminLogout , { ( TRUE => HOME ) } , { nav-empty } ) .
 
 op sAdminLogout : -> Script .
 eq [sAdminLogout] : sAdminLogout = 
        updateDB(s("adminPage") , s("free") )
		.

 -------------------------------------------------------------------------
 --- Logout page
 op logoutPage : -> Page .
 eq [logoutPage] : logoutPage = ( LOGOUT , sLogout , { ( TRUE => WELCOME ) } , { nav-empty } ) .
 
 op sLogout : -> Script .
 eq [sLogout] : sLogout = 
        clearSession
		.

 -------------------------------------------------------------------------
 ---- Web Application 
 op wapp : -> Page .
 eq [wapp] : wapp =  welcomePage : homePage : emailListPage : viewEmailPage  : 
            changeAccountPage : administrationPage  : adminLogoutPage : logoutPage   .

endm

---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------------------------

--- mod WEBAPP-CHECK is pr TLR[WEBAPP] .    
mod WEBAPP-CHECK is including MODEL-CHECKER + WEBAPP .

 subsorts WebState < State .

 vars idb idb1 idb2 idw idw1 idw2  : Id .
 vars q q1 : Query .
 vars z z1 z2 : Sigma .
 vars url urls urls1 urls2 : URL .
 vars ms pms lms lms1 lms2 : Message .
 vars rms : ReadyMessage .
 vars sv : Server .
 vars ss ss1 ss2 : Session .
 vars uss : UserSession .
 vars brs : Browser .
 vars db : DB .
 vars ide : String .
 vars wapp : Page .
 vars machina : WebState .
 vars n n1 n2 : Int .
 vars idlm idlm1 idlm2 : Nat .
 vars h h1 h2 : History .
 vars page : Qid .
 vars v : Value .
 vars ba : BrowserActions .

  --- request of login (revisar, en realidad es un requerimiento de ir a la pagian home)
  op requestLogin : Id -> Prop .
  eq [requestLogin1] : [ brs ] ba [ m( idb, idw, ( HOME ? q ) , idlm ) : ms  ] [ sv ] |= requestLogin(idb) = true .
  eq [requestLogin2] :  [ brs ] ba [ ms ] [ sv ] |= requestLogin(idb) = false [owise] .

  --- login ok
  op loginOk : Id -> Prop .
  eq [loginOk1] :  [ B( idb, idw, HOME , url, ss, z, lms, h, idlm) : brs ] ba [ ms ] [ sv ] |= loginOk(idb) = true .
  eq [loginOk2] :  [ brs ] ba [ ms ] [ sv ] |= loginOk(idb) = false [owise] .

  --- Access to administration 
  op accessToAdmin :  -> Prop .
  eq  [accessToAdmin1] :  [ B(idb1, idw1, ADMINISTRATION, urls1, ss1, z1, lms1, h1, idlm1 ) :
		B(idb2, idw2, ADMINISTRATION, urls2, ss2, z2, lms2, h2, idlm2 ) : brs ] ba 
	  [ ms ] [ sv ] |= accessToAdmin = true .
	   
  eq  [accessToAdmin2] :  [ brs ] ba [ ms ] [ sv ] |= accessToAdmin = false [owise] .

  --- Page not found 
  op isPageNotFound :  -> Prop .
  eq  [isPageNotFound1] :  [ B(idb, idw, pageNotFound, urls, ss, z, lms, h, idlm ) : brs ] ba [ ms ] [ sv ] |= isPageNotFound = true .
  eq  [isPageNotFound2] :  [ brs ] ba [ ms ] [ sv ] |= isPageNotFound = false [owise] .

  --- ReqIni - current page
  op currentPage : Id Qid -> Prop .
  eq [currentPage1] :   [ B(idb, idw, page, urls, ss, z, lms, h, idlm) : brs ] ba [ ms ] [ sv ] |= currentPage(idb, page) = true .
  eq [currentPage2] :   [ brs ] ba [ ms ] [ sv ] |= currentPage(idb, page) = false [owise] .

  --- ReqFin - request 
  op request : Id Qid -> Prop .
  eq [request1] :   [ brs ] ba [ m( idb, idw, (page ? q ), idlm ) : ms  ] [ sv ] |= request(idb, page) = true .
  eq [request2] :   [ brs ] ba [ ms ] [ sv ] |= request(idb, page) = false [owise] .

  op atWellcome : Id -> Prop .
  eq [atWellcome] :  atWellcome(idb) = currentPage(idb, WELCOME) .

  --- ReqIni - request Home
  op requestHome : Id -> Prop .
  eq [requestHome1] :   [ brs ] ba [ m( idb, idw, (HOME ? q ), idlm ) : ms  ] [ sv ] |= requestHome(idb) = true .
  eq [requestHome2] :   [ brs ] ba [ ms ] [ sv ] |= requestHome(idb) = false [owise] .

  ---- each user only can see their own emails
  op reqViewEmail :  -> Prop .
  eq [reqViewEmail1] :    [ brs ] ba 
       [ m( idb, idw, (VIEW-EMAIL ? q ), idlm ) : ms  ] 
	   [ sv ]
	|= reqViewEmail = true .
	
  eq [reqViewEmail2] :   [ brs ] ba [ ms ] [ sv ] |= reqViewEmail = false [owise] . 
    
  op validIdEmail :  -> Prop .
  eq [validIdEmail1] :    [ brs ] ba 
       [ m( idb, idw, (VIEW-EMAIL ? ('idEmail '= ide) ), idlm ) : ms  ] 
	   [ S(wapp ,  us( idb, ( s("idEmails-found") ,  s(ide) ) : ss  ) : uss , pms , rms , db ) ]
	|= validIdEmail = true .
	
  eq [validIdEmail2] :   [ brs ] ba [ ms ] [ sv ] |= validIdEmail  = false [owise] . 
  
endm


mod WEBAPP-PROPERTIES is inc WEBAPP-CHECK .

  ops idA idw1 idB idw2 idC idD : -> Id .

 -------------------------------------------------------------------------
 --- Server
 op sv : -> Server .
 eq [sv] : sv = S( wapp , uss , mes-empty, readymes-empty , db ) .
 
 op uss : -> UserSession .
 eq [uss] : uss = usersession-empty . 
 
 op db : -> DB .
 eq [db] : db = (s("bob") ; s("secretBob"))     (s("bob-role") ; s("admin"))
         (s("alice") ; s("secretAlice")) (s("alice-role") ; s("admin")) 
		 (s("adminPage") ;  s("free")) 
		 
		 (s("alice-email") ; s("email1"))
		 (s("bob-email")   ; s("email2"))
		 
		 (s("email1") ; s("text-email-one"))
		 (s("email2") ; s("text-email-two"))
		 .

 -------------------------------------------------------------------------
 --- Browser A
 op brA : -> Browser .
 eq [brA] : brA = newBrowser (idA, idw1, (WELCOME ? query-empty), zA) .

 op zA : -> Sigma  .
 eq [zA] : zA =  ('user / "alice") : ('pass / "secretAlice" ) : ('idEmail / "email2") .


 op zAB : -> Sigma  .
 eq [zAB] : zAB =  ('user / "alice") : ('pass / "secretAlice" ) : ('idEmail / "email2") .

 -------------------------------------------------------------------------
 --- Browser B
 op brB : -> Browser .
 eq [brB] : brB = newBrowser (idB, idw2, (WELCOME ? query-empty), zB) .

 op zB : -> Sigma  .
 eq [zB] : zB =  ('user / "bob") : ('pass / "secretBob" ) : ('idEmail / "email3") .

 -------------------------------------------------------------------------
 --- Initial States			

 op initial-1 : -> WebState .
 eq initial-1 = [ brA ] bra-empty [ mes-empty ] [ sv ] .

 op initial-2 : -> WebState .
 eq initial-2 = [ brA : brB ] bra-empty [ mes-empty ] [ sv ] .

 ops state0 state1 state2 state3 stateRI1 stateRI2  stateN : -> WebState .
   eq [state0] : state0 = [B(idA,idw1,'noPage,'Welcome ? query-empty,session-empty,('idEmail /
    "email2") : ('pass / "secretAlice") : 'user / "alice",mes-empty,
    history-empty,1)]bra-empty[mes-empty][S(('Admin-Logout,updateDB(s(
    "adminPage"), s("free")),{(TRUE => 'Home)},{nav-empty}) : ('Administration,
    'adminPage := selectDB(s("adminPage")) ; if 'adminPage = s("free") then
    updateDB(s("adminPage"), getSession(s("user"))) ; setSession(s(
    "adminPage"), s("free")) else setSession(s("adminPage"), s("busy")) fi,{(s(
    "adminPage") '== s("busy") => 'Home)},{(TRUE -> 'Admin-Logout ?
    query-empty)}) : ('Change-account,skip,{cont-empty},{(TRUE -> 'Home ? (
    'newPass '= "") : 'newUser '= "")}) : ('Email-list,'u := getSession(s(
    "user")) ; 'es := selectDB('u '. s("-email")) ; setSession(s(
    "idEmails-found"), 'es),{cont-empty},{(TRUE -> 'Home ? query-empty) : (TRUE
    -> 'View-email ? 'idEmail '= "")}) : ('Home,'login := getSession(s(
    "login")) ; if 'login = null then 'u := getQuery('user) ; 'p := getQuery(
    'pass) ; 'p1 := selectDB('u) ; if 'p = 'p1 then 'r := selectDB('u '. s(
    "-role")) ; setSession(s("user"), 'u) ; setSession(s("role"), 'r) ;
    setSession(s("login"), s("ok")) else setSession(s("login"), s("no")) fi fi,
    {(s("changeLogin") '== s("no") => 'Change-account) : (s("login") '== s(
    "no") => 'Welcome) : (s("login") '== s("ok") => 'Home)},{(TRUE ->
    'Change-account ? query-empty) : (TRUE -> 'Email-list ? query-empty) : (
    TRUE -> 'Logout ? query-empty) : (s("role") '== s("admin") ->
    'Administration ? query-empty)}) : ('Logout,clearSession,{(TRUE =>
    'Welcome)},{nav-empty}) : ('View-email,'u := getSession(s("user")) ; 'id :=
    getQuery('idEmail) ; 'e := selectDB('id) ; setSession(s("text-email"), 'e),
    {cont-empty},{(TRUE -> 'Email-list ? query-empty) : (TRUE -> 'Home ?
    query-empty)}) : ('Welcome,skip,{cont-empty},{(TRUE -> 'Home ? ('pass '=
    "") : 'user '= "")}),us(idA,session-empty),mes-empty,readymes-empty,(s(
    "adminPage") ; s("free")) (s("alice") ; s("secretAlice")) (s("alice-email")
    ; s("email1")) (s("alice-role") ; s("admin")) (s("bob") ; s("secretBob")) (
    s("bob-email") ; s("email2")) (s("bob-role") ; s("admin")) (s("email1") ;
    s("text-email-one")) (s("email2") ; s("text-email-two")))] .

    eq [stateN] : stateN = [B(
    idA,idw1,'Welcome,'Home ? ('pass '= "") : 'user '= "",session-empty,(
    'idEmail / "email2") : ('pass / "secretAlice") : 'user / "alice",m(idA,
    idw1,'Welcome ? query-empty,1),history-empty,1)]bra-empty[mes-empty][S((
    'Admin-Logout,updateDB(s("adminPage"), s("free")),{(TRUE => 'Home)},{
    nav-empty}) : ('Administration,'adminPage := selectDB(s("adminPage")) ; if
    'adminPage = s("free") then updateDB(s("adminPage"), getSession(s("user")))
    ; setSession(s("adminPage"), s("free")) else setSession(s("adminPage"), s(
    "busy")) fi,{(s("adminPage") '== s("busy") => 'Home)},{(TRUE ->
    'Admin-Logout ? query-empty)}) : ('Change-account,skip,{cont-empty},{(TRUE
    -> 'Home ? ('newPass '= "") : 'newUser '= "")}) : ('Email-list,'u :=
    getSession(s("user")) ; 'es := selectDB('u '. s("-email")) ; setSession(s(
    "idEmails-found"), 'es),{cont-empty},{(TRUE -> 'Home ? query-empty) : (TRUE
    -> 'View-email ? 'idEmail '= "")}) : ('Home,'login := getSession(s(
    "login")) ; if 'login = null then 'u := getQuery('user) ; 'p := getQuery(
    'pass) ; 'p1 := selectDB('u) ; if 'p = 'p1 then 'r := selectDB('u '. s(
    "-role")) ; setSession(s("user"), 'u) ; setSession(s("role"), 'r) ;
    setSession(s("login"), s("ok")) else setSession(s("login"), s("no")) fi fi,
    {(s("changeLogin") '== s("no") => 'Change-account) : (s("login") '== s(
    "no") => 'Welcome) : (s("login") '== s("ok") => 'Home)},{(TRUE ->
    'Change-account ? query-empty) : (TRUE -> 'Email-list ? query-empty) : (
    TRUE -> 'Logout ? query-empty) : (s("role") '== s("admin") ->
    'Administration ? query-empty)}) : ('Logout,clearSession,{(TRUE =>
    'Welcome)},{nav-empty}) : ('View-email,'u := getSession(s("user")) ; 'id :=
    getQuery('idEmail) ; 'e := selectDB('id) ; setSession(s("text-email"), 'e),
    {cont-empty},{(TRUE -> 'Email-list ? query-empty) : (TRUE -> 'Home ?
    query-empty)}) : ('Welcome,skip,{cont-empty},{(TRUE -> 'Home ? ('pass '=
    "") : 'user '= "")}),us(idA,session-empty),mes-empty,readymes-empty,(s(
    "adminPage") ; s("free")) (s("alice") ; s("secretAlice")) (s("alice-email")
    ; s("email1")) (s("alice-role") ; s("admin")) (s("bob") ; s("secretBob")) (
    s("bob-email") ; s("email2")) (s("bob-role") ; s("admin")) (s("email1") ;
    s("text-email-one")) (s("email2") ; s("text-email-two")))] .

    eq [state1] : state1 = [B(idA,idw1,'PageNameEmpty,
    url-empty,session-empty,('idEmail / "email2") : ('pass / "secretAlice") :
    'user / "alice",m(idA,idw1,'Welcome ? query-empty,1),history-empty,
    1)]bra-empty[mes-empty][S(('Admin-Logout,updateDB(s("adminPage"), s(
    "free")),{(TRUE => 'Home)},{nav-empty}) : ('Administration,'adminPage :=
    selectDB(s("adminPage")) ; if 'adminPage = s("free") then updateDB(s(
    "adminPage"), getSession(s("user"))) ; setSession(s("adminPage"), s(
    "free")) else setSession(s("adminPage"), s("busy")) fi,{(s("adminPage") '==
    s("busy") => 'Home)},{(TRUE -> 'Admin-Logout ? query-empty)}) : (
    'Change-account,skip,{cont-empty},{(TRUE -> 'Home ? ('newPass '= "") :
    'newUser '= "")}) : ('Email-list,'u := getSession(s("user")) ; 'es :=
    selectDB('u '. s("-email")) ; setSession(s("idEmails-found"), 'es),{
    cont-empty},{(TRUE -> 'Home ? query-empty) : (TRUE -> 'View-email ?
    'idEmail '= "")}) : ('Home,'login := getSession(s("login")) ; if 'login =
    null then 'u := getQuery('user) ; 'p := getQuery('pass) ; 'p1 := selectDB(
    'u) ; if 'p = 'p1 then 'r := selectDB('u '. s("-role")) ; setSession(s(
    "user"), 'u) ; setSession(s("role"), 'r) ; setSession(s("login"), s("ok"))
    else setSession(s("login"), s("no")) fi fi,{(s("changeLogin") '== s("no")
    => 'Change-account) : (s("login") '== s("no") => 'Welcome) : (s("login")
    '== s("ok") => 'Home)},{(TRUE -> 'Change-account ? query-empty) : (TRUE ->
    'Email-list ? query-empty) : (TRUE -> 'Logout ? query-empty) : (s("role")
    '== s("admin") -> 'Administration ? query-empty)}) : ('Logout,clearSession,
    {(TRUE => 'Welcome)},{nav-empty}) : ('View-email,'u := getSession(s(
    "user")) ; 'id := getQuery('idEmail) ; 'e := selectDB('id) ; setSession(s(
    "text-email"), 'e),{cont-empty},{(TRUE -> 'Email-list ? query-empty) : (
    TRUE -> 'Home ? query-empty)}) : ('Welcome,skip,{cont-empty},{(TRUE ->
    'Home ? ('pass '= "") : 'user '= "")}),us(idA,session-empty),mes-empty,rm(
    m(idA,idw1,'Welcome,'Home ? ('pass '= "") : 'user '= "",session-empty,1),
    session-empty,(s("adminPage") ; s("free")) (s("alice") ; s("secretAlice"))
    (s("alice-email") ; s("email1")) (s("alice-role") ; s("admin")) (s("bob") ;
    s("secretBob")) (s("bob-email") ; s("email2")) (s("bob-role") ; s("admin"))
    (s("email1") ; s("text-email-one")) (s("email2") ; s("text-email-two"))),
    block-db)] .

endm
